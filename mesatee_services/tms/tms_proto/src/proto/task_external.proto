syntax = "proto2";
package tms_external;
import "cred.proto";

// input argument in TaskAgreement
message InputArg {
    // private input or fusion input
    required bool is_private = 1;
    // owners of the input: private - single owner, fusion - multiple owners
    repeated string owners = 2;
    // data id of the input
    required string data_id = 3;
}

// output argument in TaskAgreement
message OutputArg {
    // private output or fusion output
    required bool is_private = 1;
    // owners of the input: private - single owner, fusion - multiple owners
    repeated string owners = 2;
    // data id of the output
    // fusion output may not have a data id before the TaskAgreement is accepted by the TMS
    optional string data_id = 3;
}

// TaskAgreement contains all the information to invoke a task
// But sensitive data is represented by data id.
// Multiple participants can consent to the TaskAgreement offline.
message TaskAgreement {
    // Task identifier
    required string task_id = 1;
    // Function identifier
    required string function_id = 2;
    // Input arguments
    map<string, InputArg> input_arguments = 3;
    // Output arguments
    map<string, OutputArg> output_argments = 4;
    // Participants
    repeated string participants = 5;
    // Signatures of the participants
    map<string, bytes> signatures = 6;
}

// Request for registering a Task, in order to propose a TaskAgreement
message RegisterTaskRequest {
    // Function identifier
    required string function_id = 1;
    // Participants
    repeated string participants = 2;
    // User credential
    required cred_proto.Credential creds = 99; 
} 

// Response for registering a Task
message RegisterTaskResponse {
    // initial TaskAgreement
    required TaskAgreement initial_agreement = 1;
}

// Task status
enum TaskStatus {
    // If a Task is registered, the status is Initial
    Initial = 1;
    // If the TaskAgreement is approved by all the participants and accepted by the TMS, the status is Pending
    Pending = 2;
    // If the Task is scheduled and being executed in a worker, the status is Running
    Running = 3;
    // If the Task is executed successfully, the status is Successful
    Successful = 4;
    // If the Task is failed to be executed or accepted by the TMS, the status is Failed.
    Failed = 5;
}

// Request for getting a Task
message GetTaskRequest {
    // Task identifier
    required string task_id = 1;
    // User credential
    required cred_proto.Credential creds = 99; 
} 

// Response for getting a Task
message GetTaskResponse {
    // TaskAgreement
    required TaskAgreement agreement = 1;
    // Task Status
    required TaskStatus statuts = 2;
}

// Request for invoking a Task
message InvokeTaskRequest {
    // A complete TaskAgreement: required inputs and outputs are provided, all the participants approved the task.
    required TaskAgreement complete_agreement = 1;
    // User credential
    required cred_proto.Credential creds = 99; 
}

// Response for invoking a Task
// The invocation is asynchronous. Participants need to use GetTaskRequest to query the task status.
// Participants need to use the (logical and physical) data information they provided to access the output data.
message InvokeTaskResponse {
    // whether the task is successfully invoked.
    required bool success = 1;
}

service TaskService {
    // Client can use this request to propose a Task
    rpc RegisterTask(RegisterTaskRequest) returns (RegisterTaskResponse);
    // Client can use this request to query Task information.
    rpc GetTask(GetTaskRequest) returns (GetTaskResponse);
    // Client can use this request to invoke a Task.
    rpc InvokeTask(InvokeTaskRequest) returns (InvokeTaskResponse);
}